<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suivi du Sommeil Quantique PWA</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sommeil Quantique">
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Optional: Custom font for better aesthetics */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom scrollbar for Webkit browsers (Chrome, Safari) */
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
            background: #374151; /* gray-700 */
            border-radius: 10px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: #2563eb; /* blue-600 */
            border-radius: 10px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: #1d4ed8; /* blue-700 */
        }

        /* Custom Keyframe Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes fadeInScaleUp {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        /* Apply animations using Tailwind's arbitrary values or custom classes */
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        .animate-fade-in-scale-up {
            animation: fadeInScaleUp 0.3s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // React et ReactDOM sont maintenant disponibles globalement grâce aux scripts UMD ci-dessus
        const { useState, useEffect, useRef } = React;

        // Helper function to format duration
        const formatDuration = (hours, minutes, seconds) => {
            // Ensure leading zeros for single-digit minutes/seconds
            const pad = (num) => num.toString().padStart(2, '0');
            return `${hours}h ${pad(minutes)}m ${pad(seconds)}s`;
        };

        // Helper function to calculate duration between two Date objects
        const calculateDuration = (startDate, endDate) => {
            const durationMs = endDate.getTime() - startDate.getTime();
            const hours = Math.floor(durationMs / (1000 * 60 * 60));
            const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((durationMs % (1000 * 60)) / 1000);
            return { hours, minutes, seconds };
        };

        // Main App component
        const App = () => {
            // State to store sleep records
            const [sleepRecords, setSleepRecords] = useState([]);
            // State to store the current sleep start time
            const [sleepStartTime, setSleepStartTime] = useState(null);
            // State to display messages to the user
            const [message, setMessage] = useState('');
            // State to store the sleep analysis generated by the LLM
            const [sleepAnalysis, setSleepAnalysis] = useState('');
            // State to manage loading state for LLM analysis
            const [isLoadingAnalysis, setIsLoadingAnalysis] = useState(false);
            // State to control the manual entry modal visibility
            const [showManualEntryModal, setShowManualEntryModal] = useState(false);
            // State for manual start time input
            const [manualStartTime, setManualStartTime] = '';
            // State for manual end time input
            const [manualEndTime, setManualEndTime] = '';
            // State for displaying current sleep duration
            const [currentSleepDuration, setCurrentSleepDuration] = useState(null);
            // State for confirmation modal
            const [showConfirmDeleteModal, setShowConfirmDeleteModal] = useState(false);
            const [recordToDelete, setRecordToDelete] = useState(null);

            // Audio recording states
            const [isRecordingSnore, setIsRecordingSnore] = useState(false);
            const [mediaRecorder, setMediaRecorder] = useState(null);
            const [audioChunks, setAudioChunks] = useState([]);
            const [recordedSnoreURL, setRecordedSnoreURL] = useState(null);
            const [isSnorePlaying, setIsSnorePlaying] = useState(false);

            // State for generated bedtime content
            const [bedtimeContent, setBedtimeContent] = useState('');
            const [isLoadingBedtimeContent, setIsLoadingBedtimeContent] = useState(false);

            // Ref for the message timeout
            const messageTimeoutRef = useRef(null);

            // Effect to clear messages after a delay
            useEffect(() => {
                if (message) {
                    if (messageTimeoutRef.current) {
                        clearTimeout(messageTimeoutRef.current);
                    }
                    messageTimeoutRef.current = setTimeout(() => {
                        setMessage('');
                    }, 5000); // Clear message after 5 seconds
                }
                return () => {
                    if (messageTimeoutRef.current) {
                        clearTimeout(messageTimeoutRef.current);
                    }
                };
            }, [message]);

            // Load sleep records from localStorage on initial render
            useEffect(() => {
                try {
                    const storedRecords = localStorage.getItem('sleepRecords');
                    if (storedRecords) {
                        setSleepRecords(JSON.parse(storedRecords));
                    }
                } catch (error) {
                    console.error("Erreur lors du chargement des enregistrements de sommeil:", error);
                    setMessage("Erreur lors du chargement des données.");
                }
            }, []);

            // Save sleep records to localStorage whenever they change
            useEffect(() => {
                try {
                    localStorage.setItem('sleepRecords', JSON.stringify(sleepRecords));
                } catch (error) {
                    console.error("Erreur lors de la sauvegarde des enregistrements de sommeil:", error);
                    setMessage("Erreur lors de la sauvegarde des données.");
                }
            }, [sleepRecords]);

            // Effect to update current sleep duration every second
            useEffect(() => {
                let interval = null;
                if (sleepStartTime) {
                    interval = setInterval(() => {
                        const start = new Date(sleepStartTime);
                        const now = new Date();
                        const { hours, minutes, seconds } = calculateDuration(start, now);
                        setCurrentSleepDuration(formatDuration(hours, minutes, seconds));
                    }, 1000);
                } else {
                    setCurrentSleepDuration(null);
                }
                return () => clearInterval(interval);
            }, [sleepStartTime]);

            /**
             * Handles the "Start Sleep" button click.
             * Records the current time as the sleep start time.
             */
            const handleStartSleep = () => {
                const now = new Date();
                setSleepStartTime(now.toISOString()); // Store as ISO string for easy parsing
                setMessage('Sommeil démarré à ' + now.toLocaleTimeString('fr-FR'));
                setSleepAnalysis(''); // Clear previous analysis
                setRecordedSnoreURL(null); // Clear previous snore recording
                setAudioChunks([]); // Clear audio chunks
                setBedtimeContent(''); // Clear bedtime content
            };

            /**
             * Handles the "End Sleep" button click.
             * Records the current time as the sleep end time, calculates duration,
             * and adds the record to the list.
             */
            const handleEndSleep = () => {
                if (!sleepStartTime) {
                    setMessage('Veuillez d\'abord démarrer le sommeil.');
                    return;
                }

                const now = new Date();
                const start = new Date(sleepStartTime);
                const { hours, minutes, seconds } = calculateDuration(start, now);

                const newRecord = {
                    id: Date.now(), // Unique ID for the record
                    startTime: sleepStartTime,
                    endTime: now.toISOString(),
                    duration: { hours, minutes, seconds }
                    // Note: recordedSnoreURL is NOT persisted in localStorage due to size limitations.
                    // It's only available for the current session.
                };

                setSleepRecords(prevRecords => [newRecord, ...prevRecords]); // Add new record to the top
                setSleepStartTime(null); // Reset sleep start time
                setMessage(`Sommeil terminé. Durée: ${formatDuration(hours, minutes, seconds)}`);
                setSleepAnalysis(''); // Clear previous analysis
                setBedtimeContent(''); // Clear bedtime content
                // Do not clear recordedSnoreURL here if we want to play it after session ends
            };

            /**
             * Shows the confirmation modal for deleting a record.
             * @param {number} id - The ID of the record to delete.
             */
            const confirmDeleteRecord = (id) => {
                setRecordToDelete(id);
                setShowConfirmDeleteModal(true);
            };

            /**
             * Deletes a sleep record by its ID after confirmation.
             */
            const handleDeleteRecord = () => {
                if (recordToDelete) {
                    setSleepRecords(prevRecords => prevRecords.filter(record => record.id !== recordToDelete));
                    setMessage('Enregistrement supprimé.');
                    setSleepAnalysis(''); // Clear previous analysis
                    setRecordToDelete(null);
                    setShowConfirmDeleteModal(false);
                    setBedtimeContent(''); // Clear bedtime content
                }
            };

            /**
             * Formats a date string into a more readable format.
             * @param {string} dateString - The ISO date string.
             * @returns {string} Formatted date and time.
             */
            const formatDateTime = (dateString) => {
                const date = new Date(dateString);
                return date.toLocaleDateString('fr-FR', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };

            /**
             * Handles manual sleep record submission.
             */
            const handleManualAdd = () => {
                if (!manualStartTime || !manualEndTime) {
                    setMessage('Veuillez entrer les heures de début et de fin pour l\'enregistrement manuel.');
                    return;
                }

                const start = new Date(manualStartTime);
                const end = new Date(manualEndTime);

                if (end <= start) {
                    setMessage('L\'heure de fin doit être après l\'heure de début.');
                    return;
                }

                const { hours, minutes, seconds } = calculateDuration(start, end);

                const newRecord = {
                    id: Date.now(),
                    startTime: manualStartTime,
                    endTime: manualEndTime,
                    duration: { hours, minutes, seconds }
                };

                setSleepRecords(prevRecords => [newRecord, ...prevRecords]);
                setMessage('Enregistrement manuel ajouté.');
                setShowManualEntryModal(false);
                setManualStartTime('');
                setManualEndTime('');
                setSleepAnalysis(''); // Clear previous analysis
                setRecordedSnoreURL(null); // Clear previous snore recording
                setAudioChunks([]); // Clear audio chunks
                setBedtimeContent(''); // Clear bedtime content
            };

            /**
             * Calls the Gemini API to get sleep analysis.
             */
            const getSleepAnalysis = async () => {
                if (sleepRecords.length === 0) {
                    setMessage('Veuillez enregistrer au moins un sommeil pour obtenir une analyse.');
                    return;
                }

                setIsLoadingAnalysis(true);
                setMessage('Obtention des informations sur le sommeil...');
                setSleepAnalysis(''); // Clear previous analysis

                try {
                    // Construct the prompt with sleep records
                    const formattedRecords = sleepRecords.map(record => ({
                        date: new Date(record.startTime).toLocaleDateString('fr-FR'),
                        startTime: new Date(record.startTime).toLocaleTimeString('fr-FR'),
                        endTime: new Date(record.endTime).toLocaleTimeString('fr-FR'),
                        duration: `${record.duration.hours}h ${record.duration.minutes}m ${record.duration.seconds}s`
                    }));

                    const prompt = `Based on the following sleep records, please provide a comprehensive analysis in French.
Include:
1.  **Summary of Sleep Patterns:** Describe the general sleep habits observed (e.g., consistent, variable, average bedtime/wake-up time).
2.  **Average Sleep Duration:** Calculate and state the average sleep duration.
3.  **Trends and Observations:** Highlight any notable trends (e.g., shorter sleep on weekdays, longer on weekends, changes over time).
4.  **Personalized Advice:** Offer actionable and general advice for improving sleep quality based on these specific records.

Here are the sleep records:
${JSON.stringify(formattedRecords, null, 2)}
`;

                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = { contents: chatHistory };
                    const apiKey = ""; // API key is provided by the Canvas environment
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        setSleepAnalysis(text);
                        setMessage('Analyse du sommeil générée.');
                    } else {
                        setSleepAnalysis('Impossible de générer l\'analyse du sommeil. Veuillez réessayer.');
                        setMessage('Erreur lors de l\'analyse du sommeil.');
                    }
                } catch (error) {
                    console.error("Erreur lors de l'appel à l'API Gemini:", error);
                    setSleepAnalysis('Une erreur est survenue lors de la génération de l\'analyse.');
                    setMessage('Erreur de connexion à l\'API.');
                } finally {
                    setIsLoadingAnalysis(false);
                }
            };

            /**
             * Starts recording audio from the microphone.
             */
            const startSnoreRecording = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const recorder = new MediaRecorder(stream);
                    setMediaRecorder(recorder);
                    setAudioChunks([]); // Clear previous chunks

                    recorder.ondataavailable = (event) => {
                        setAudioChunks((prev) => [...prev, event.data]);
                    };

                    recorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        setRecordedSnoreURL(audioUrl);
                        // Clean up stream tracks
                        stream.getTracks().forEach(track => track.stop());
                        setMessage('Enregistrement de ronflement terminé.');
                    };

                    recorder.start();
                    setIsRecordingSnore(true);
                    setMessage('Enregistrement du ronflement démarré...');
                } catch (err) {
                    console.error('Erreur d\'accès au microphone:', err);
                    setMessage('Impossible d\'accéder au microphone. Veuillez autoriser l\'accès.');
                }
            };

            /**
             * Stops audio recording.
             */
            const stopSnoreRecording = () => {
                if (mediaRecorder && isRecordingSnore) {
                    mediaRecorder.stop();
                    setIsRecordingSnore(false);
                }
            };

            /**
             * Plays the recorded snore sound.
             */
            const playSnoreRecording = () => {
                if (recordedSnoreURL) {
                    const audio = new Audio(recordedSnoreURL);
                    audio.onplay = () => setIsSnorePlaying(true);
                    audio.onended = () => setIsSnorePlaying(false);
                    audio.onerror = (e) => {
                        console.error("Erreur de lecture audio:", e);
                        setMessage("Erreur lors de la lecture du ronflement.");
                        setIsSnorePlaying(false);
                    };
                    audio.play();
                }
            };

            /**
             * Generates a bedtime story or meditation using Gemini API.
             */
            const generateBedtimeContent = async () => {
                setIsLoadingBedtimeContent(true);
                setBedtimeContent(''); // Clear previous content
                setMessage('Génération de contenu pour le sommeil...');

                try {
                    const prompt = `Génère un court texte apaisant pour aider à s'endormir. Ce peut être une histoire douce, une méditation guidée simple, ou une description relaxante d'un paysage calme. Le texte doit être en français et ne pas dépasser 200 mots.`;

                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = { contents: chatHistory };
                    const apiKey = ""; // API key is provided by the Canvas environment
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        setBedtimeContent(text);
                        setMessage('Contenu pour le sommeil généré.');
                    } else {
                        setBedtimeContent('Impossible de générer le contenu pour le sommeil. Veuillez réessayer.');
                        setMessage('Erreur lors de la génération du contenu.');
                    }
                } catch (error) {
                    console.error("Erreur lors de l'appel à l'API Gemini pour le contenu de sommeil:", error);
                    setBedtimeContent('Une erreur est survenue lors de la génération du contenu.');
                    setMessage('Erreur de connexion à l\'API.');
                } finally {
                    setIsLoadingBedtimeContent(false);
                }
            };


            return (
                // Main container with futuristic background gradient
                <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-950 to-purple-950 flex flex-col items-center justify-center p-4 font-sans text-gray-100">
                    {/* Main application card */}
                    <div className="bg-gray-800 p-8 rounded-xl shadow-2xl shadow-blue-900/50 w-full max-w-md text-center transform transition-all duration-300 hover:scale-105 border border-blue-700">
                        <h1 className="text-4xl font-extrabold text-cyan-400 mb-6 drop-shadow-lg">Suivi du Sommeil Quantique</h1>

                        {/* Current sleep status and messages */}
                        <div className="mb-6">
                            {sleepStartTime ? (
                                <>
                                    <p className="text-lg text-blue-200">
                                        Sommeil en cours depuis: <span className="font-semibold text-cyan-300">{formatDateTime(sleepStartTime)}</span>
                                    </p>
                                    {currentSleepDuration && (
                                        <p className="text-2xl font-bold text-indigo-400 mt-2 animate-pulse">
                                            Durée actuelle: {currentSleepDuration}
                                        </p>
                                    )}
                                </>
                            ) : (
                                <p className="text-lg text-blue-200">Prêt à suivre votre sommeil.</p>
                            )}
                            {message && (
                                <p className="mt-2 text-md text-green-400 font-medium animate-fade-in">{message}</p>
                            )}
                        </div>

                        {/* Start/End Sleep Buttons */}
                        <div className="flex justify-center space-x-4 mb-8">
                            <button
                                onClick={handleStartSleep}
                                disabled={sleepStartTime !== null} // Disable if sleep is already started
                                className="bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-600 hover:to-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed ring-2 ring-cyan-400 ring-opacity-50"
                            >
                                Démarrer le Sommeil
                            </button>
                            <button
                                onClick={handleEndSleep}
                                disabled={sleepStartTime === null} // Disable if sleep is not started
                                className="bg-gradient-to-r from-purple-500 to-indigo-600 hover:from-purple-600 hover:to-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed ring-2 ring-purple-400 ring-opacity-50"
                            >
                                Terminer le Sommeil
                            </button>
                        </div>

                        {/* Snore Recording Section */}
                        <div className="mb-8 p-4 bg-gray-700 rounded-lg border border-blue-600 shadow-inner">
                            <h3 className="text-xl font-bold text-blue-300 mb-3">Enregistrement de Ronflement</h3>
                            <div className="flex justify-center space-x-4">
                                <button
                                    onClick={startSnoreRecording}
                                    disabled={isRecordingSnore}
                                    className="bg-gradient-to-r from-pink-500 to-red-600 hover:from-pink-600 hover:to-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transform transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed ring-2 ring-pink-400 ring-opacity-50"
                                >
                                    {isRecordingSnore ? 'Enregistrement...' : 'Démarrer Ronflement'}
                                </button>
                                <button
                                    onClick={stopSnoreRecording}
                                    disabled={!isRecordingSnore}
                                    className="bg-gradient-to-r from-red-600 to-pink-500 hover:from-red-700 hover:to-pink-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transform transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed ring-2 ring-red-400 ring-opacity-50"
                                >
                                    Arrêter Ronflement
                                </button>
                            </div>
                            {recordedSnoreURL && (
                                <div className="mt-4">
                                    <button
                                        onClick={playSnoreRecording}
                                        disabled={isSnorePlaying}
                                        className="bg-gradient-to-r from-lime-500 to-green-600 hover:from-lime-600 hover:to-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transform transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed ring-2 ring-lime-400 ring-opacity-50"
                                    >
                                        {isSnorePlaying ? 'Lecture...' : 'Écouter le ronflement'}
                                    </button>
                                    <p className="text-sm text-gray-400 mt-2">
                                        (L'enregistrement n'est pas sauvegardé de manière permanente)
                                    </p>
                                </div>
                            )}
                        </div>

                        {/* Manual Add Button */}
                        <button
                            onClick={() => setShowManualEntryModal(true)}
                            className="mb-6 bg-gradient-to-r from-teal-500 to-green-600 hover:from-teal-600 hover:to-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transform transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 ring-2 ring-teal-400 ring-opacity-50"
                        >
                            Ajouter un enregistrement manuel
                        </button>

                        {/* Gemini Analysis Button */}
                        <button
                            onClick={getSleepAnalysis}
                            disabled={sleepRecords.length === 0 || isLoadingAnalysis}
                            className="mt-4 bg-gradient-to-r from-green-500 to-lime-600 hover:from-green-600 hover:to-lime-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center mx-auto ring-2 ring-lime-400 ring-opacity-50"
                        >
                            {isLoadingAnalysis ? (
                                <>
                                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.062 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    Analyse en cours...
                                </>
                            ) : (
                                <>
                                    Obtenir des informations sur le sommeil ✨
                                </>
                            )}
                        </button>

                        {/* Sleep Analysis Display */}
                        {sleepAnalysis && (
                            <div className="mt-8 p-6 bg-blue-900 rounded-lg shadow-inner text-left border border-blue-700 animate-fade-in">
                                <h3 className="text-xl font-bold text-blue-300 mb-3">Analyse du Sommeil</h3>
                                <p className="text-blue-200 whitespace-pre-wrap">{sleepAnalysis}</p>
                            </div>
                        )}

                        {/* Bedtime Content Generator Button */}
                        <button
                            onClick={generateBedtimeContent}
                            disabled={isLoadingBedtimeContent}
                            className="mt-8 bg-gradient-to-r from-orange-500 to-yellow-600 hover:from-orange-600 hover:to-yellow-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center mx-auto ring-2 ring-yellow-400 ring-opacity-50"
                        >
                            {isLoadingBedtimeContent ? (
                                <>
                                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.062 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    Génération en cours...
                                </>
                            ) : (
                                <>
                                    Générer une histoire/méditation pour dormir ✨
                                </>
                            )}
                        </button>

                        {/* Bedtime Content Display */}
                        {bedtimeContent && (
                            <div className="mt-8 p-6 bg-purple-900 rounded-lg shadow-inner text-left border border-purple-700 animate-fade-in">
                                <h3 className="text-xl font-bold text-purple-300 mb-3">Contenu pour le Sommeil</h3>
                                <p className="text-purple-200 whitespace-pre-wrap">{bedtimeContent}</p>
                            </div>
                        )}
                    </div>

                    {/* Manual Entry Modal */}
                    {showManualEntryModal && (
                        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 animate-fade-in-scale-up">
                            <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm border border-blue-700">
                                <h3 className="text-2xl font-bold text-cyan-400 mb-4">Ajouter un enregistrement manuel</h3>
                                <div className="mb-4">
                                    <label htmlFor="manual-start" className="block text-blue-200 text-sm font-bold mb-2">Heure de début:</label>
                                    <input
                                        type="datetime-local"
                                        id="manual-start"
                                        value={manualStartTime}
                                        onChange={(e) => setManualStartTime(e.target.value)}
                                        className="shadow appearance-none border rounded w-full py-2 px-3 bg-gray-700 text-white leading-tight focus:outline-none focus:shadow-outline border-blue-600"
                                    />
                                </div>
                                <div className="mb-6">
                                    <label htmlFor="manual-end" className="block text-blue-200 text-sm font-bold mb-2">Heure de fin:</label>
                                    <input
                                        type="datetime-local"
                                        id="manual-end"
                                        value={manualEndTime}
                                        onChange={(e) => setManualEndTime(e.target.value)}
                                        className="shadow appearance-none border rounded w-full py-2 px-3 bg-gray-700 text-white leading-tight focus:outline-none focus:shadow-outline border-blue-600"
                                    />
                                </div>
                                <div className="flex justify-end space-x-4">
                                    <button
                                        onClick={() => setShowManualEntryModal(false)}
                                        className="bg-gray-700 hover:bg-gray-600 text-gray-200 font-bold py-2 px-4 rounded-lg transform transition-transform duration-200 active:scale-95"
                                    >
                                        Annuler
                                    </button>
                                    <button
                                        onClick={handleManualAdd}
                                        className="bg-gradient-to-r from-teal-500 to-green-600 hover:from-teal-600 hover:to-green-700 text-white font-bold py-2 px-4 rounded-lg transform transition-transform duration-200 active:scale-95"
                                    >
                                        Ajouter
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Confirm Delete Modal */}
                    {showConfirmDeleteModal && (
                        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 animate-fade-in-scale-up">
                            <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm text-center border border-blue-700">
                                <h3 className="text-xl font-bold text-cyan-400 mb-4">Confirmer la suppression</h3>
                                <p className="text-blue-200 mb-6">Êtes-vous sûr de vouloir supprimer cet enregistrement de sommeil ?</p>
                                <div className="flex justify-center space-x-4">
                                    <button
                                        onClick={() => setShowConfirmDeleteModal(false)}
                                        className="bg-gray-700 hover:bg-gray-600 text-gray-200 font-bold py-2 px-4 rounded-lg transform transition-transform duration-200 active:scale-95"
                                    >
                                        Annuler
                                    </button>
                                    <button
                                        onClick={handleDeleteRecord}
                                        className="bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg transform transition-transform duration-200 active:scale-95"
                                    >
                                        Supprimer
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<React.StrictMode><App /></React.StrictMode>);
    </script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js', { scope: '/' })
                    .then(registration => {
                        console.log('ServiceWorker enregistré avec succès:', registration);
                    })
                    .catch(error => {
                        console.error('Échec de l\'enregistrement du ServiceWorker:', error);
                    });
            });
        }
    </script>
</body>
</html>
